section .text

global distance_kernel_asm

; Computes Euclidean distances between 2D points using scalar SIMD instructions
; Arguments: X1 (rcx), X2 (rdx), Y1 (r8), Y2 (r9), Z ([rbp+48]), n ([rbp+56])
distance_kernel_asm:
    push rbp
    mov rbp, rsp
    push rbx
    push r12
    push r13
    push r14
    push r15
    sub rsp, 32 ; shadow space for Windows x64 ABI

    mov rbx, [rbp + 48]    ; Z (output array)
    mov r10d, [rbp + 56]   ; n (number of elements)

    mov r12, rcx           ; X1
    mov r13, rdx           ; X2
    mov r14, r8            ; Y1
    mov r15, r9            ; Y2

    xor edi, edi           ; i = 0 (loop counter)

.loop:
    cmp edi, r10d          ; if (i >= n) break
    jge .done

    mov eax, edi
    shl eax, 2             ; offset = i * 4 (float size)

    movss xmm0, [r13 + rax] ; xmm0 = X2[i]
    movss xmm1, [r12 + rax] ; xmm1 = X1[i]
    subss xmm0, xmm1        ; xmm0 = X2[i] - X1[i]
    movss xmm2, xmm0        ; xmm2 = dx
    mulss xmm2, xmm0        ; xmm2 = dx^2

    movss xmm3, [r15 + rax] ; xmm3 = Y2[i]
    movss xmm4, [r14 + rax] ; xmm4 = Y1[i]
    subss xmm3, xmm4        ; xmm3 = Y2[i] - Y1[i]
    movss xmm5, xmm3        ; xmm5 = dy
    mulss xmm5, xmm3        ; xmm5 = dy^2

    addss xmm2, xmm5        ; xmm2 = dx^2 + dy^2
    sqrtss xmm2, xmm2       ; xmm2 = sqrt(dx^2 + dy^2)

    movss [rbx + rax], xmm2 ; Z[i] = result

    inc edi                 ; i++
    jmp .loop

.done:
    add rsp, 32
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    pop rbp
    ret
